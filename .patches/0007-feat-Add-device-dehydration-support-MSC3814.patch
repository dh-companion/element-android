From 9373f2e04150e8f834ff3f127ab8cff43acc29da Mon Sep 17 00:00:00 2001
From: LukaRusadze <rusadzeluka@gmail.com>
Date: Wed, 14 Jan 2026 18:33:36 +0400
Subject: [PATCH] feat: Add device dehydration support (MSC3814)

Implements MSC3814 device dehydration for Android, matching iOS implementation:
- Add REST API endpoints for dehydrated devices
- Add DehydrationService with full dehydration/rehydration flow
- Expose dehydratedDevices() from Rust SDK via OlmMachine
- Add runDeviceDehydrationFlow() to CryptoService interface
---
 .../sdk/api/session/crypto/CryptoService.kt   |  27 ++
 .../android/sdk/internal/crypto/OlmMachine.kt |   9 +
 .../sdk/internal/crypto/RustCryptoService.kt  |  14 +
 .../sdk/internal/crypto/api/CryptoApi.kt      |  45 +++
 .../crypto/dehydration/DehydrationService.kt  | 269 ++++++++++++++++++
 .../model/rest/DehydratedDeviceModels.kt      |  60 ++++
 6 files changed, 424 insertions(+)
 create mode 100644 matrix-sdk-android/src/main/java/org/matrix/android/sdk/internal/crypto/dehydration/DehydrationService.kt
 create mode 100644 matrix-sdk-android/src/main/java/org/matrix/android/sdk/internal/crypto/model/rest/DehydratedDeviceModels.kt

diff --git a/matrix-sdk-android/src/main/java/org/matrix/android/sdk/api/session/crypto/CryptoService.kt b/matrix-sdk-android/src/main/java/org/matrix/android/sdk/api/session/crypto/CryptoService.kt
index fa1208059a..4947d23bb8 100644
--- a/matrix-sdk-android/src/main/java/org/matrix/android/sdk/api/session/crypto/CryptoService.kt
+++ b/matrix-sdk-android/src/main/java/org/matrix/android/sdk/api/session/crypto/CryptoService.kt
@@ -233,6 +233,33 @@ interface CryptoService {
     suspend fun onSyncWillProcess(isInitialSync: Boolean)
     fun isStarted(): Boolean
 
+    // region Device Dehydration (MSC3814)
+
+    /**
+     * Run the device dehydration flow (MSC3814).
+     *
+     * This should be called after:
+     * 1. Security setup is complete (cross-signing bootstrapped, SSSS set up)
+     * 2. Secrets are recovered from recovery key or passphrase
+     *
+     * The flow will:
+     * - Check if a dehydrated device pickle key exists in SSSS
+     * - If yes: rehydrate the existing device, process its events, delete it, and create a new one
+     * - If no: generate a new pickle key, store it in SSSS, and create a new dehydrated device
+     *
+     * @param privateKeyData The private key data for accessing secret storage (from recovery key or passphrase)
+     */
+    suspend fun runDeviceDehydrationFlow(privateKeyData: ByteArray)
+
+    /**
+     * Check if device dehydration is available.
+     *
+     * @return true if dehydration can be performed (crypto is set up)
+     */
+    fun isDehydrationAvailable(): Boolean
+
+    // endregion
+
     suspend fun receiveSyncChanges(
             toDevice: ToDeviceSyncResponse?,
             deviceChanges: DeviceListResponse?,
diff --git a/matrix-sdk-android/src/main/java/org/matrix/android/sdk/internal/crypto/OlmMachine.kt b/matrix-sdk-android/src/main/java/org/matrix/android/sdk/internal/crypto/OlmMachine.kt
index bbc4c3bb39..8b953333d7 100644
--- a/matrix-sdk-android/src/main/java/org/matrix/android/sdk/internal/crypto/OlmMachine.kt
+++ b/matrix-sdk-android/src/main/java/org/matrix/android/sdk/internal/crypto/OlmMachine.kt
@@ -70,6 +70,7 @@ import org.matrix.rustcomponents.sdk.crypto.CrossSigningKeyExport
 import org.matrix.rustcomponents.sdk.crypto.CrossSigningStatus
 import org.matrix.rustcomponents.sdk.crypto.CryptoStoreException
 import org.matrix.rustcomponents.sdk.crypto.DecryptionException
+import org.matrix.rustcomponents.sdk.crypto.DehydratedDevices
 import org.matrix.rustcomponents.sdk.crypto.DeviceLists
 import org.matrix.rustcomponents.sdk.crypto.EncryptionSettings
 import org.matrix.rustcomponents.sdk.crypto.KeyRequestPair
@@ -157,6 +158,14 @@ internal class OlmMachine @Inject constructor(
         return inner
     }
 
+    /**
+     * Get the dehydrated devices manager.
+     * Used for MSC3814 device dehydration support.
+     */
+    fun dehydratedDevices(): DehydratedDevices {
+        return inner.dehydratedDevices()
+    }
+
     private suspend fun updateLiveDevices() {
         flowCollectors.forEachDevicesCollector {
             val devices = getCryptoDeviceInfo(it.userIds)
diff --git a/matrix-sdk-android/src/main/java/org/matrix/android/sdk/internal/crypto/RustCryptoService.kt b/matrix-sdk-android/src/main/java/org/matrix/android/sdk/internal/crypto/RustCryptoService.kt
index c998f104f4..04bc51c1ab 100755
--- a/matrix-sdk-android/src/main/java/org/matrix/android/sdk/internal/crypto/RustCryptoService.kt
+++ b/matrix-sdk-android/src/main/java/org/matrix/android/sdk/internal/crypto/RustCryptoService.kt
@@ -71,6 +71,7 @@ import org.matrix.android.sdk.api.session.sync.model.SyncResponse
 import org.matrix.android.sdk.api.session.sync.model.ToDeviceSyncResponse
 import org.matrix.android.sdk.api.util.Optional
 import org.matrix.android.sdk.api.util.toOptional
+import org.matrix.android.sdk.internal.crypto.dehydration.DehydrationService
 import org.matrix.android.sdk.internal.crypto.keysbackup.RustKeyBackupService
 import org.matrix.android.sdk.internal.crypto.model.SessionInfo
 import org.matrix.android.sdk.internal.crypto.network.OutgoingRequestsProcessor
@@ -135,6 +136,7 @@ internal class RustCryptoService @Inject constructor(
         private val outgoingRequestsProcessor: OutgoingRequestsProcessor,
         private val matrixConfiguration: MatrixConfiguration,
         private val perSessionBackupQueryRateLimiter: PerSessionBackupQueryRateLimiter,
+        private val dehydrationService: DehydrationService,
 ) : CryptoService {
 
     private val isStarting = AtomicBoolean(false)
@@ -296,6 +298,18 @@ internal class RustCryptoService @Inject constructor(
     // Always enabled on Matrix Android SDK2
     override fun isCryptoEnabled() = true
 
+    // region Device Dehydration (MSC3814)
+
+    override suspend fun runDeviceDehydrationFlow(privateKeyData: ByteArray) {
+        dehydrationService.runDeviceDehydrationFlow(privateKeyData)
+    }
+
+    override fun isDehydrationAvailable(): Boolean {
+        return dehydrationService.isDehydrationAvailable()
+    }
+
+    // endregion
+
     /**
      * @return the Keys backup Service
      */
diff --git a/matrix-sdk-android/src/main/java/org/matrix/android/sdk/internal/crypto/api/CryptoApi.kt b/matrix-sdk-android/src/main/java/org/matrix/android/sdk/internal/crypto/api/CryptoApi.kt
index d496d14780..564205ac39 100644
--- a/matrix-sdk-android/src/main/java/org/matrix/android/sdk/internal/crypto/api/CryptoApi.kt
+++ b/matrix-sdk-android/src/main/java/org/matrix/android/sdk/internal/crypto/api/CryptoApi.kt
@@ -18,6 +18,10 @@ package org.matrix.android.sdk.internal.crypto.api
 import org.matrix.android.sdk.api.session.crypto.model.DeviceInfo
 import org.matrix.android.sdk.api.session.crypto.model.DevicesListResponse
 import org.matrix.android.sdk.api.util.JsonDict
+import org.matrix.android.sdk.internal.crypto.model.rest.CreateDehydratedDeviceResponse
+import org.matrix.android.sdk.internal.crypto.model.rest.DehydratedDeviceEventsRequest
+import org.matrix.android.sdk.internal.crypto.model.rest.DehydratedDeviceEventsResponse
+import org.matrix.android.sdk.internal.crypto.model.rest.DehydratedDeviceResponse
 import org.matrix.android.sdk.internal.crypto.model.rest.DeleteDeviceParams
 import org.matrix.android.sdk.internal.crypto.model.rest.DeleteDevicesParams
 import org.matrix.android.sdk.internal.crypto.model.rest.KeyChangesResponse
@@ -32,6 +36,7 @@ import org.matrix.android.sdk.internal.crypto.model.rest.UpdateDeviceInfoBody
 import org.matrix.android.sdk.internal.crypto.model.rest.UploadSigningKeysBody
 import org.matrix.android.sdk.internal.network.NetworkConstants
 import retrofit2.http.Body
+import retrofit2.http.DELETE
 import retrofit2.http.GET
 import retrofit2.http.HTTP
 import retrofit2.http.POST
@@ -171,4 +176,44 @@ internal interface CryptoApi {
             @Query("from") oldToken: String,
             @Query("to") newToken: String
     ): KeyChangesResponse
+
+    // region Device Dehydration (MSC3814)
+
+    /**
+     * Create or replace a dehydrated device.
+     * MSC3814: https://github.com/matrix-org/matrix-spec-proposals/pull/3814
+     *
+     * @param body the dehydrated device data from the Rust SDK
+     */
+    @PUT(NetworkConstants.URI_API_PREFIX_PATH_UNSTABLE + "org.matrix.msc3814.v1/dehydrated_device")
+    suspend fun createDehydratedDevice(@Body body: JsonDict): CreateDehydratedDeviceResponse
+
+    /**
+     * Retrieve the dehydrated device.
+     * MSC3814: https://github.com/matrix-org/matrix-spec-proposals/pull/3814
+     */
+    @GET(NetworkConstants.URI_API_PREFIX_PATH_UNSTABLE + "org.matrix.msc3814.v1/dehydrated_device")
+    suspend fun getDehydratedDevice(): DehydratedDeviceResponse
+
+    /**
+     * Delete the dehydrated device.
+     * MSC3814: https://github.com/matrix-org/matrix-spec-proposals/pull/3814
+     */
+    @DELETE(NetworkConstants.URI_API_PREFIX_PATH_UNSTABLE + "org.matrix.msc3814.v1/dehydrated_device")
+    suspend fun deleteDehydratedDevice()
+
+    /**
+     * Get to-device events for a dehydrated device.
+     * MSC3814: https://github.com/matrix-org/matrix-spec-proposals/pull/3814
+     *
+     * @param deviceId the dehydrated device id
+     * @param body optional next_batch token for pagination
+     */
+    @POST(NetworkConstants.URI_API_PREFIX_PATH_UNSTABLE + "org.matrix.msc3814.v1/dehydrated_device/{deviceId}/events")
+    suspend fun getDehydratedDeviceEvents(
+            @Path("deviceId") deviceId: String,
+            @Body body: DehydratedDeviceEventsRequest
+    ): DehydratedDeviceEventsResponse
+
+    // endregion
 }
diff --git a/matrix-sdk-android/src/main/java/org/matrix/android/sdk/internal/crypto/dehydration/DehydrationService.kt b/matrix-sdk-android/src/main/java/org/matrix/android/sdk/internal/crypto/dehydration/DehydrationService.kt
new file mode 100644
index 0000000000..66cce708ac
--- /dev/null
+++ b/matrix-sdk-android/src/main/java/org/matrix/android/sdk/internal/crypto/dehydration/DehydrationService.kt
@@ -0,0 +1,269 @@
+/*
+ * Copyright 2024 The Matrix.org Foundation C.I.C.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.matrix.android.sdk.internal.crypto.dehydration
+
+import android.util.Base64
+import kotlinx.coroutines.withContext
+import org.matrix.android.sdk.api.MatrixCoroutineDispatchers
+import org.matrix.android.sdk.api.session.securestorage.IntegrityResult
+import org.matrix.android.sdk.api.session.securestorage.KeyInfoResult
+import org.matrix.android.sdk.api.session.securestorage.KeyRef
+import org.matrix.android.sdk.api.session.securestorage.RawBytesKeySpec
+import org.matrix.android.sdk.api.session.securestorage.SharedSecretStorageService
+import org.matrix.android.sdk.internal.crypto.OlmMachine
+import org.matrix.android.sdk.internal.crypto.api.CryptoApi
+import org.matrix.android.sdk.internal.crypto.model.rest.DehydratedDeviceEventsRequest
+import org.matrix.android.sdk.internal.di.MoshiProvider
+import org.matrix.android.sdk.internal.session.SessionScope
+import org.matrix.rustcomponents.sdk.crypto.DehydratedDeviceKey
+import org.matrix.rustcomponents.sdk.crypto.RehydratedDevice
+import retrofit2.HttpException
+import timber.log.Timber
+import java.security.SecureRandom
+import javax.inject.Inject
+import javax.inject.Provider
+
+/**
+ * Service for handling device dehydration (MSC3814).
+ *
+ * Device dehydration allows a user to have a "backup device" that can receive
+ * room keys while they have no active devices logged in. When they log in again,
+ * the dehydrated device is rehydrated and the room keys are recovered.
+ */
+@SessionScope
+internal class DehydrationService @Inject constructor(
+        private val olmMachineProvider: Provider<OlmMachine>,
+        private val cryptoApi: CryptoApi,
+        private val sharedSecretStorageService: SharedSecretStorageService,
+        private val coroutineDispatchers: MatrixCoroutineDispatchers,
+) {
+
+    companion object {
+        /** Secret ID for storing the dehydrated device pickle key in SSSS (MSC3814). */
+        const val DEHYDRATED_DEVICE_SECRET_ID = "org.matrix.msc3814"
+
+        /** Display name for the dehydrated device. */
+        private const val DEVICE_DISPLAY_NAME = "Backup Device"
+    }
+
+    private val olmMachine: OlmMachine
+        get() = olmMachineProvider.get()
+
+    /**
+     * Run the device dehydration flow.
+     *
+     * This will:
+     * 1. Check if a pickle key exists in secret storage
+     * 2. If yes: rehydrate the existing device, process its events, delete it, and create a new one
+     * 3. If no: generate a new pickle key, store it, and create a new dehydrated device
+     *
+     * @param privateKeyData The private key data for accessing secret storage (from recovery key or passphrase)
+     */
+    suspend fun runDeviceDehydrationFlow(privateKeyData: ByteArray) {
+        withContext(coroutineDispatchers.io) {
+            try {
+                runDeviceDehydrationFlowInternal(privateKeyData)
+            } catch (e: Exception) {
+                Timber.e(e, "Failed device dehydration flow")
+            }
+        }
+    }
+
+    private suspend fun runDeviceDehydrationFlowInternal(privateKeyData: ByteArray) {
+        val defaultKeyResult = sharedSecretStorageService.getDefaultKey()
+        val defaultKeyId = when (defaultKeyResult) {
+            is KeyInfoResult.Success -> defaultKeyResult.keyInfo.id
+            is KeyInfoResult.Error -> {
+                Timber.e("No default secret storage key available")
+                return
+            }
+        }
+
+        val keySpec = RawBytesKeySpec(privateKeyData)
+
+        // Check if we have a dehydration pickle key stored
+        val hasPickleKey = sharedSecretStorageService.checkShouldBeAbleToAccessSecrets(
+                secretNames = listOf(DEHYDRATED_DEVICE_SECRET_ID),
+                keyId = defaultKeyId
+        ) is IntegrityResult.Success
+
+        if (hasPickleKey) {
+            // Retrieve existing pickle key from secret storage
+            val base64PickleKey = try {
+                sharedSecretStorageService.getSecret(
+                        name = DEHYDRATED_DEVICE_SECRET_ID,
+                        keyId = defaultKeyId,
+                        secretKey = keySpec
+                )
+            } catch (e: Exception) {
+                Timber.e(e, "Failed to retrieve dehydration pickle key from secret storage")
+                return
+            }
+
+            val pickleKeyData = Base64.decode(base64PickleKey, Base64.NO_WRAP)
+
+            // Try to rehydrate existing device
+            try {
+                val (deviceId, rehydratedDevice) = rehydrateDevice(pickleKeyData)
+                Timber.i("Successfully rehydrated device: $deviceId")
+
+                // Process to-device events from the dehydrated device
+                processToDeviceEvents(rehydratedDevice, deviceId)
+
+                // Delete the old dehydrated device
+                try {
+                    deleteDehydratedDevice()
+                    Timber.i("Deleted old dehydrated device")
+                } catch (e: Exception) {
+                    Timber.w(e, "Failed to delete old dehydrated device, continuing anyway")
+                }
+            } catch (e: NoDehydratedDeviceException) {
+                Timber.i("No dehydrated device available, will create a new one")
+            } catch (e: Exception) {
+                Timber.e(e, "Failed to rehydrate device")
+                return
+            }
+
+            // Create a new dehydrated device with the same pickle key
+            try {
+                dehydrateDevice(pickleKeyData)
+                Timber.i("Created new dehydrated device")
+            } catch (e: Exception) {
+                Timber.e(e, "Failed to create dehydrated device")
+            }
+        } else {
+            // Generate a new pickle key (32 random bytes)
+            val pickleKeyData = ByteArray(32).also { SecureRandom().nextBytes(it) }
+            val base64PickleKey = Base64.encodeToString(pickleKeyData, Base64.NO_WRAP)
+
+            // Store the pickle key in secret storage
+            try {
+                sharedSecretStorageService.storeSecret(
+                        name = DEHYDRATED_DEVICE_SECRET_ID,
+                        secretBase64 = base64PickleKey,
+                        keys = listOf(KeyRef(keyId = defaultKeyId, keySpec = keySpec))
+                )
+                Timber.i("Stored dehydration pickle key in secret storage")
+            } catch (e: Exception) {
+                Timber.e(e, "Failed to store dehydration pickle key")
+                return
+            }
+
+            // Create a new dehydrated device
+            try {
+                dehydrateDevice(pickleKeyData)
+                Timber.i("Created new dehydrated device")
+            } catch (e: Exception) {
+                Timber.e(e, "Failed to create dehydrated device")
+            }
+        }
+    }
+
+    /**
+     * Create a new dehydrated device and upload it to the server.
+     */
+    private suspend fun dehydrateDevice(pickleKeyData: ByteArray) {
+        val dehydratedDevices = olmMachine.dehydratedDevices()
+        val dehydratedDevice = dehydratedDevices.create()
+
+        val request = dehydratedDevice.keysForUpload(
+                DEVICE_DISPLAY_NAME,
+                DehydratedDeviceKey(pickleKeyData)
+        )
+
+        // Parse the request body and send to server
+        val moshi = MoshiProvider.providesMoshi()
+        @Suppress("UNCHECKED_CAST")
+        val body = moshi.adapter(Map::class.java).fromJson(request.body) as? Map<String, Any>
+                ?: throw IllegalStateException("Failed to parse dehydrated device request body")
+
+        cryptoApi.createDehydratedDevice(body)
+    }
+
+    /**
+     * Retrieve and rehydrate an existing dehydrated device.
+     *
+     * @return A pair of the device ID and the rehydrated device
+     * @throws NoDehydratedDeviceException if no dehydrated device exists
+     */
+    private suspend fun rehydrateDevice(pickleKeyData: ByteArray): Pair<String, RehydratedDevice> {
+        val response = try {
+            cryptoApi.getDehydratedDevice()
+        } catch (e: HttpException) {
+            if (e.code() == 404) {
+                throw NoDehydratedDeviceException()
+            }
+            throw e
+        }
+
+        val moshi = MoshiProvider.providesMoshi()
+        val deviceDataJson = moshi.adapter(Map::class.java).toJson(response.deviceData)
+
+        val rehydratedDevice = olmMachine.dehydratedDevices().rehydrate(
+                DehydratedDeviceKey(pickleKeyData),
+                response.deviceId,
+                deviceDataJson
+        )
+
+        return response.deviceId to rehydratedDevice
+    }
+
+    /**
+     * Process all to-device events that were sent to the dehydrated device.
+     */
+    private suspend fun processToDeviceEvents(rehydratedDevice: RehydratedDevice, deviceId: String) {
+        var nextBatch: String? = null
+
+        do {
+            val request = DehydratedDeviceEventsRequest(nextBatch = nextBatch)
+            val response = cryptoApi.getDehydratedDeviceEvents(deviceId, request)
+
+            if (response.events.isNotEmpty()) {
+                val moshi = MoshiProvider.providesMoshi()
+                val eventsJson = moshi.adapter(List::class.java).toJson(response.events)
+                rehydratedDevice.receiveEvents(eventsJson)
+                Timber.d("Processed ${response.events.size} to-device events from dehydrated device")
+            }
+
+            nextBatch = response.nextBatch
+        } while (response.events.isNotEmpty())
+    }
+
+    /**
+     * Delete the current dehydrated device from the server.
+     */
+    private suspend fun deleteDehydratedDevice() {
+        cryptoApi.deleteDehydratedDevice()
+    }
+
+    /**
+     * Check if device dehydration is available (i.e., if we have crypto set up).
+     */
+    fun isDehydrationAvailable(): Boolean {
+        return try {
+            olmMachine.dehydratedDevices()
+            true
+        } catch (e: Exception) {
+            false
+        }
+    }
+}
+
+/**
+ * Exception thrown when no dehydrated device exists on the server.
+ */
+internal class NoDehydratedDeviceException : Exception("No dehydrated device available")
diff --git a/matrix-sdk-android/src/main/java/org/matrix/android/sdk/internal/crypto/model/rest/DehydratedDeviceModels.kt b/matrix-sdk-android/src/main/java/org/matrix/android/sdk/internal/crypto/model/rest/DehydratedDeviceModels.kt
new file mode 100644
index 0000000000..59102a48c2
--- /dev/null
+++ b/matrix-sdk-android/src/main/java/org/matrix/android/sdk/internal/crypto/model/rest/DehydratedDeviceModels.kt
@@ -0,0 +1,60 @@
+/*
+ * Copyright 2024 The Matrix.org Foundation C.I.C.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.matrix.android.sdk.internal.crypto.model.rest
+
+import com.squareup.moshi.Json
+import com.squareup.moshi.JsonClass
+
+/**
+ * Response from PUT /_matrix/client/unstable/org.matrix.msc3814.v1/dehydrated_device
+ */
+@JsonClass(generateAdapter = true)
+internal data class CreateDehydratedDeviceResponse(
+        @Json(name = "device_id")
+        val deviceId: String
+)
+
+/**
+ * Response from GET /_matrix/client/unstable/org.matrix.msc3814.v1/dehydrated_device
+ */
+@JsonClass(generateAdapter = true)
+internal data class DehydratedDeviceResponse(
+        @Json(name = "device_id")
+        val deviceId: String,
+        @Json(name = "device_data")
+        val deviceData: Map<String, Any>
+)
+
+/**
+ * Request body for POST /_matrix/client/unstable/org.matrix.msc3814.v1/dehydrated_device/{deviceId}/events
+ */
+@JsonClass(generateAdapter = true)
+internal data class DehydratedDeviceEventsRequest(
+        @Json(name = "next_batch")
+        val nextBatch: String? = null
+)
+
+/**
+ * Response from POST /_matrix/client/unstable/org.matrix.msc3814.v1/dehydrated_device/{deviceId}/events
+ */
+@JsonClass(generateAdapter = true)
+internal data class DehydratedDeviceEventsResponse(
+        @Json(name = "events")
+        val events: List<Map<String, Any>> = emptyList(),
+        @Json(name = "next_batch")
+        val nextBatch: String? = null
+)
-- 
2.39.5 (Apple Git-154)

